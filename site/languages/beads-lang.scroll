import header.scroll

title beads-lang

title beads-lang - Programming language
 hidden

html
 <a class="prevLang" href="kaitai.html">&lt;</a>
 <a class="nextLang" href="ipf.html">&gt;</a>

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/beads-lang.pldb

startColumns 4

html <div class="quickLinks"><a href="http://beadslang.org/"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.7166 3.79541C12.2835 3.49716 11.7165 3.49716 11.2834 3.79541L4.14336 8.7121C3.81027 8.94146 3.60747 9.31108 3.59247 9.70797C3.54064 11.0799 3.4857 13.4824 3.63658 15.1877C3.7504 16.4742 4.05336 18.1747 4.29944 19.4256C4.41371 20.0066 4.91937 20.4284 5.52037 20.4284H8.84433C8.98594 20.4284 9.10074 20.3111 9.10074 20.1665V15.9754C9.10074 14.9627 9.90433 14.1417 10.8956 14.1417H13.4091C14.4004 14.1417 15.204 14.9627 15.204 15.9754V20.1665C15.204 20.3111 15.3188 20.4284 15.4604 20.4284H18.4796C19.0806 20.4284 19.5863 20.0066 19.7006 19.4256C19.9466 18.1747 20.2496 16.4742 20.3634 15.1877C20.5143 13.4824 20.4594 11.0799 20.4075 9.70797C20.3925 9.31108 20.1897 8.94146 19.8566 8.7121L12.7166 3.79541ZM10.4235 2.49217C11.3764 1.83602 12.6236 1.83602 13.5765 2.49217L20.7165 7.40886C21.4457 7.91098 21.9104 8.73651 21.9448 9.64736C21.9966 11.0178 22.0564 13.5119 21.8956 15.3292C21.7738 16.7067 21.4561 18.4786 21.2089 19.7353C20.9461 21.0711 19.7924 22.0001 18.4796 22.0001H15.4604C14.4691 22.0001 13.6655 21.1791 13.6655 20.1665V15.9754C13.6655 15.8307 13.5507 15.7134 13.4091 15.7134H10.8956C10.754 15.7134 10.6392 15.8307 10.6392 15.9754V20.1665C10.6392 21.1791 9.83561 22.0001 8.84433 22.0001H5.52037C4.20761 22.0001 3.05389 21.0711 2.79113 19.7353C2.54392 18.4786 2.22624 16.7067 2.10437 15.3292C1.94358 13.5119 2.00338 11.0178 2.05515 9.64736C2.08957 8.73652 2.55427 7.91098 3.28346 7.40886L10.4235 2.49217Z"/></svg></a></div>

* beads-lang is a <a href="../lists/languages.html?filter=pl">programming language</a> created in 2016 by Edward de Jong.
 link ../lists/languages.html?filter=2016 2016
 link ../lists/creators.html#edwardDeJong Edward de Jong

kpiTable
 #566 <span title="TotalRank: 1127 Jobs: 103 Users: 2404 Facts: 52 Links: 972">on PLDB</span>
 7 Years Old
 0 <span title="Books about or leveraging beads-lang">Books</span>
 0 <span title="Academic publications about or leveraging beads-lang">Papers</span>

* 

- beads-lang website
 http://beadslang.org/
- beads-lang first developed in <a href="../lists/originCommunities.html#edwardDeJong">Edward de Jong</a>
- file extensions for beads-lang include beads
- <a href="http://beadslang.org/">beadslang.org</a> was registered in 2016
- Read more about beads-lang on the web: 1.
 https://docs.google.com/spreadsheets/d/12sTu7RT-s_QlAupY1v-3DfI1Mm9NEX5YMWWTDAKHLfc/edit#gid=0 1.
- HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
- <a href="https://pldb.com/edit/beads-lang">Improve our beads-lang file</a>

html <br>

codeWithHeader Example from the web:
 beads level 1 program calculator
 //  flutter version available at: on github, look for: flutter-calculator-demo
 //  article: https://itnext.io/building-a-calculator-app-in-flutter-824254704fe6
 
 const
   C_OP    = #3E424D  //  keycap fill for an operator like C
   C_DIGIT = #6E6E6E  //  keycap fill for a digit
   C_ARITH  = #1A4C6E //  keycap fill for arithmetic buttons
 
   //  warning: you must use the same unicode math chars in case statements later in arithmetic()
   KEYCAPS = [ &#39;C&#39;, &#39;±&#39;, &#39;%&#39;, &#39;÷&#39;,  //  tried \u207A\u2215\u208B instead of ± but it is ugly
         &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;x&#39;, 
         &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;−&#39;, // \u2212 is the minus sign 
         &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;,
         &#39;&#39;, &#39;0&#39;, &#39;.&#39;, &#39;=&#39;]  // &#39;⌫&#39; is U+232B, for future undo key
 
   KEYCOLORS = [C_OP, C_OP, C_OP, C_ARITH,
         C_DIGIT, C_DIGIT, C_DIGIT, C_ARITH,
         C_DIGIT, C_DIGIT, C_DIGIT, C_ARITH,
         C_DIGIT, C_DIGIT, C_DIGIT, C_ARITH,
         C_OP, C_DIGIT, C_OP, C_ARITH]
 
   SPACING = 3 // points between each cell
   HAIR = &quot;\u2009&quot;  //  a thin space 200A is even thinner
 
 record a_term
   ss : str  // the string containing the contents of the term
   op : str  // the operator in keycap string form &#39;+&#39;, &#39;-&#39;...
 
 record a_state
   terms : array of a_term
   termx : num  // which term we are on
   chain_op : str  //  chain operator char for repeated = presses
   chain_val: num  //  chain value to repeat
   fresh : yesno   //  if this is Y, then next digit will clear existing value
 
 var g : a_state
 
 calc main_init
   g.terms[1].ss = &quot;&quot;
   g.termx = 1
   g.fresh = Y
 
 vert slice main_draw
   var cellsize = if b.box.width &gt; b.box.height then b.box.height/8 else b.box.width/4
   var result_v = cellsize*2  //  need to enhance compiler so that expressions don&#39;t get converted 
   var keys_v = cellsize*5
   var keys_maxh = min(b.box.width, cellsize*8)  // don&#39;t go wider than 8 squares wide (double)
   draw_rect(b.box, fill:#121F30)
   skip 10 al
   add result_v px d_result
   add keys_v px d_keys(keys_maxh)
   skip 10 al
 
 draw d_result
   draw_rect(b.box, fill:#0D161F)
 
   //  build the string out of the active terms
   var s : str = &quot;&quot;
   loop array:g.terms index:i
     g.terms[i].ss &amp;=&gt; s
     if g.terms[i].op &lt;&gt; U
       HAIR &amp; g.terms[i].op &amp; HAIR &amp;=&gt; s  // append the operator
 
   if (s == &quot;&quot;)
     s = &quot;0&quot;  //  when nothing is entered into our expression, call it zero
 
   draw_str(b.box, s, size:b.box.height*0.5, just:RIGHT, indent:20 pt, color:WHITE)
 
 horz slice d_keys(
   totwidth  -- max width we allow for the grid, might be all of the space
   )
   //  in landscape mode, we don&#39;t want the key grid to get too wide, looks bad
   skip 10 al
   add totwidth px d_keygrid
   skip 10 al
 
 table d_keygrid
   horz slice
     skip SPACING pt
     loop reps:4
       add 10 al
       skip SPACING pt
   vert slice
     skip SPACING pt
     loop reps:5
       add 10 al
       skip SPACING pt
 
   //  inside grid cell draw function, b has properties b.box, cell_seq, cell:a_xy, nrows, ncols
   cell
     draw_rect(b.box, fill:KEYCOLORS[b.cell_seq], corner:6 pt)
     draw_str(b.box, KEYCAPS[b.cell_seq], size:b.box.height, color:WHITE)
 track EV_TAP
   //  respond to the command
   case b.cell_seq
   | 1  //  clear
     do_clear
 
   | 2  //  plusminus - change the sign of the current term
     sign_change(g.termx)
 
   | 3  // percent - divide the current term by 100
     do_percent
 
   | 4, 8, 12, 16   //  arithmetic operations
     do_arith(KEYCAPS[b.cell_seq])
   
   | 17  // future feature - backspace
     nop // do_backspace
 
   | 19  // period
     do_period
 
   | 20  //  equals
     do_equals
 
   else
     //  must be a digit
     add_digit(KEYCAPS[b.cell_seq])  
 
 // calc do_backspace
 //  log &quot;backspace&quot;
 //  reserved for future undo functionality
 //  this will test ability to read code and extend it
   
 calc do_percent
   //  if the current term is empty do nothing
   //  apple&#39;s calculator takes the sequence 900+% and makes it 900^2 which is nutty
   if g.terms[g.termx].ss &lt;&gt; &quot;&quot;
     if g.termx &gt; 1
       //  when we have two terms, like 300 + 20% we take 20% of the first term and replace
       g.terms[g.termx].ss = to_str(eval(g.termx)*eval(g.termx-1)/100)
     else
       //  we only have 1 term, so just divide it by 100
       g.terms[g.termx].ss = to_str(eval(g.termx)/100)
     g.fresh = Y
 
 calc eval (
   termx  -- term index to evaluate
   ) : num  //  convert a term to a floating point number
   var ss : str = g.terms[termx].ss
   if ss == &quot;&quot;
     return 0
   return to_num(ss)
 
 calc do_clear // clear the current term to blank.
   //  if the user has entered 123+, there is an empty current term will do nothing
   g.terms[g.termx].ss = &quot;&quot;
 
 calc sign_change(
   tx  -- term index
   )
   var old : str = g.terms[tx].ss
   if old == &quot;&quot;
     //  we have no operand yet in the current term, so
     //  either ignore it or change previous operand&#39;s sign
     //  this is what apple&#39;s calculator does
     if tx &gt; 1
       sign_change(tx-1)  // change previous operand&#39;s sign. kinda weird really.
   elif str_begins(old, &quot;-&quot;)
     g.terms[tx].ss = str_subset(old, from:2)  // strip the minus
   else
     g.terms[tx].ss = &#39;-&#39; &amp; old  //  prepend a minus
 
 calc do_period
   //  ignore attempts to add more than one period
   var list : array of num
   str_find(g.terms[g.termx].ss, &quot;.&quot;, list)
   if tree_count(list) == 0
     add_digit(&quot;.&quot;)  //  no period yet, so append one
 
 calc do_equals
   var val = eval(1)  // start with the first term by itself
   var val2
 
   //  if there is no second or later term use the chain operator and value
   if tree_count(g.terms) &lt; 2
     //  use repeat if we have one
     if g.chain_op &lt;&gt; U
       val = arithmetic(g.chain_op, val, g.chain_val)
   else
     // two or more terms to process
     loop from:1 index:tx while:g.terms[tx+1].ss &lt;&gt; &quot;&quot; and g.terms[tx].op &lt;&gt; U
       val2 = eval(tx+1)
       //  remember the last operator we used as our chaining value
       g.chain_op = g.terms[tx].op
       g.chain_val = val2
       val = arithmetic(g.chain_op, val, val2)
 
   //  calculation done, convert the value back as if we entered it
   trunc g.terms // zap the array
   g.terms[1].ss = to_str(val)  //  replace our value
   g.termx = 1
   g.fresh = Y
 
 calc arithmetic(
   operand : str  -- operation like &quot;+&quot;, must match keycap
   term1   : num
   term2   : num
   ) : num -- resulting value
   var result
   case operand //  note: these operators must match the keycaps
   | &#39;+&#39;
     term1 + term2 =&gt; result
   | &#39;−&#39;
     term1 - term2 =&gt; result
   | &#39;x&#39;
     term1 * term2 =&gt; result
   | &#39;÷&#39;
     term1 / term2 =&gt; result
   else
     result = ERR
   return result
   
 calc add_digit(
   digit : str // digit to append to current term
   )
   //  if we are starting fresh, then erase what was there before
   //  we also replace the previous string if it was a leading zero
   if g.fresh or g.terms[g.termx].ss == &quot;0&quot;
     g.terms[g.termx].ss = &quot;&quot; // clear whatever was there
   digit &amp;=&gt; g.terms[g.termx].ss
   g.fresh = N
 
 calc do_arith(
   operand : str  // &#39;+&#39;, etc
   )
   if g.terms[g.termx].ss == &quot;&quot;
     //  we have no term, so treat that as replacing the previously entered operation
     //  and if this is the very beginning and we have no prior operation, ignore it
     if g.termx == 1
       // starting with a plus on an empty term is ignored
       return
   
     //  multiple operators in a row, rewrite the previous operator
     g.terms[g.termx-1].op = operand
   else
     //  we did have a term, advance to the next term 
     g.terms[g.termx].op = operand
     inc g.termx
     g.terms[g.termx].ss = &quot;&quot; // empty term 

endColumns

## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Semantic Indentation
  FeatureLink ../features/hasSemanticIndentation.html
  Supported <span class="hasFeature">✓</span>
  Token 
  Example
 row
  Feature Comments
  FeatureLink ../features/hasComments.html
  Supported <span class="hasFeature">✓</span>
  Token 
  Example
   // A comment
 row
  Feature Line Comments
  FeatureLink ../features/hasLineComments.html
  Supported <span class="hasFeature">✓</span>
  Token //
  Example
   // A comment

keyboardNav kaitai.html ipf.html

import ../footer.scroll
